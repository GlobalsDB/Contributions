My Methods:

	For a graph with 500,000 vertices and ~6 edges/vertex:

		to run listConnected1() 100,000 times took ~6 seconds

		to run listConnected2() 10 times took ~65 seconds

		to run deleteVertex() 10 times took ~60 seconds

		to run getDatum() 100,000 times took ~1.5 seconds

		to run getDatum() 500,000 times took ~4.5 seconds

		to run addEdgeDatum() safely 600,000 times took ~18 seconds
		to run addEdgeDatum() unsafely 600,000 times took ~8 seconds




	For a graph with 100,000 vertices and ~6 edges/vertex:

		to run listConnected1() 100,000 times took ~5 seconds

		to run listConnected2() 10 times took ~13 seconds

		to run deleteVertex() 10 times took ~12 seconds

		to run getDatum() 100,000 times took ~1.5 seconds




	Observations: 
		listConnected1() is O(number of edges from vertex)
		listConnected2() is O(number of vertices in graph)
		deleteVertex() is O(number of vertices in graph) because (and only because) it caalls listConnected2()



Conclusions:
	
	Several methods' efficiencies are bounded by globals alone, including listConnected1() and addVertexDatum(). I think that within globals, 
	these methods are in the best efficiency class possible.

	I believe AddEdgeDatum(), as written, is also in the best efficiency class, but its time performance can be improved by a factor of two by
	skipping some of the assertions I have included in it. Therefore I have given the option to include a 6th parameter, which, when set to
	"true", lets you skip those assertions (which can be potentially hazardous) and improve your efficiency.

	Other methods are NOT very efficient. Currently, listConnected2(), a method for finding all vertices with an edge to this vertex, checks every 
	vertex individually, which is very inefficient. Furthermore, deleteVertex uses listConnected2(), so it is slowed as well. In a future build,
	I may try to have each vertex include a list of those vertices which have edges to it, making these methods very fast.

	Overall, the program is currently limited by the time it takes to initialize data, which is limited by globals. Added more than 500,000 vertices
	(and a decent number of edges to go with them) takes a long time, so it is not recommended. However, if you do spend the time intializing these 
	vertices, the methods (except those detailed above) should remain fast.



Measurements for Other Methods:
	Running randomString() 10,000,000 times takes ~3 seconds

	Running Math.random() 100,000,000 times takes ~1.5 seconds

	calling a function takes a trivial amount of time (100,000,000 in about a second)

	evaluating an "if" takes a trivial amount of time (1,000,000,000 in about a second)

	assigning a numeric value takes a trivial amount of time (1,000,000,000 in about a second)

	printing something takes a decent amount of time (1,000,000 in about a minute), but i dont use it much

	calling set() on a global 1,000,000 times takes ~7 sec
	calling set() on a global 10,000,000 times takes ~60 sec

	calling data() on a global 10,000,000 takes ~40 sec



